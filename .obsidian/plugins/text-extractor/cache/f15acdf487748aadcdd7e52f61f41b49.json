{"path":".obsidian/plugins/text-extractor/cache/f15acdf487748aadcdd7e52f61f41b49.json","text":"1 CP312 Algorithm Design and Analysis I LECTURE 3: MERGE SORT Algorithm Design • There are various design techniques for building algorithms. • We used the incremental approach to design insertion sort • Now we will see a different approach to design a different sorting algorithm. 2 Merge Sort 9 6 2 8 3 1 7 5 10 4 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 7 8 9 10 Split1 Sort2 Sort2 Merge3 3 Merge Step 2 3 6 8 9 1 4 5 7 10 1 4 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 5 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 6 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 4 7 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 8 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 9 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 7 10 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 7 8 11 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 7 8 9 12 Merge Step 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 7 8 9 10 13 Merge Step Running Time • We are merging 2 sorted lists each of size 𝑛/2 • In every step: ◦ 1 comparison ◦ 1 copy ◦ 1 pointer increment • How many steps do we perform in the worst case? • Merge Time: 3𝑛 = Θ(𝑛) 𝑛 14 Merge Sort 9 6 2 8 3 1 7 5 10 4 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 7 8 9 10 Split1 Sort2 Sort2 Merge3 Θ(𝑛) Θ(1) 15 Merge Sort 9 6 2 8 3 1 7 5 10 4 2 3 6 8 9 1 4 5 7 10 1 2 3 4 5 6 7 8 9 10 Split1 MergeSort2 MergeSort2 Merge3 Θ(𝑛) Θ(1) 16 Merge Sort 9 6 2 8 3 1 7 5 10 4 MergeSort(𝐴, 𝑝, 𝑟): If 𝑝 < 𝑟 𝑞 = (𝑝 + 𝑟)/2 // Split in half MergeSort 𝐴, 𝑝, 𝑞 // Recursively merge-sort left half MergeSort 𝐴, 𝑞 + 1, 𝑟 // Recursively merge-sort right half Merge 𝐴, 𝑝, 𝑟 // Merge the two sorted lists 𝐴 𝑝 𝑞 𝑟 17 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 9 6 2 8 3MergeSort 𝐴, 1,5 9 6 2 9 6 MergeSort 𝐴, 1,3 MergeSort 𝐴, 1,2 9 6 18 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 9 6 2 8 3MergeSort 𝐴, 1,5 9 6 2 6 9 MergeSort 𝐴, 1,3 MergeSort 𝐴, 1,2 9 6 19 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 9 6 2 8 3MergeSort 𝐴, 1,5 9 6 2 6 9 MergeSort 𝐴, 1,3 MergeSort 𝐴, 1,2 9 6 2 20 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 9 6 2 8 3MergeSort 𝐴, 1,5 2 6 9 6 9 MergeSort 𝐴, 1,3 MergeSort 𝐴, 1,2 9 6 2 8 3 8 3 MergeSort 𝐴, 4,5 21 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 9 6 2 8 3MergeSort 𝐴, 1,5 2 6 9 6 9 MergeSort 𝐴, 1,3 MergeSort 𝐴, 1,2 9 6 2 3 8 8 3 MergeSort 𝐴, 4,5 22 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9MergeSort 𝐴, 1,5 2 6 9 6 9 MergeSort 𝐴, 1,3 MergeSort 𝐴, 1,2 9 6 2 3 8 8 3 MergeSort 𝐴, 4,5 23 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 7 5 10 4 MergeSort 𝐴, 6,10 1 7 5 MergeSort 𝐴, 6,8 1 7 1 7 MergeSort 𝐴, 6,7 24 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 7 5 10 4 MergeSort 𝐴, 6,10 1 7 5 MergeSort 𝐴, 6,8 1 7 1 7 MergeSort 𝐴, 6,7 25 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 7 5 10 4 MergeSort 𝐴, 6,10 1 7 5 MergeSort 𝐴, 6,8 1 7 1 7 5 26 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 7 5 10 4 MergeSort 𝐴, 6,10 1 5 7 MergeSort 𝐴, 6,8 1 7 1 7 5 27 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 7 5 10 4 MergeSort 𝐴, 6,10 1 5 7 1 7 1 7 5 10 4 MergeSort 𝐴, 9,10 10 4 28 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 7 5 10 4 MergeSort 𝐴, 6,10 1 5 7 1 7 1 7 5 4 10 MergeSort 𝐴, 9,10 10 4 29 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 7 5 10 4 MergeSort 𝐴, 6,10 1 5 7 1 7 1 7 5 4 10 10 4 30 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 4 5 7 10 MergeSort 𝐴, 6,10 1 5 7 1 7 1 7 5 4 10 10 4 31 Merge Sort: Recursive Sorting 9 6 2 8 3 1 7 5 10 4MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 4 5 7 10 1 5 7 1 7 1 7 5 4 10 10 4 32 Merge Sort: Recursive Sorting 1 2 3 4 5 6 7 8 9 10MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 4 5 7 10 1 5 7 1 7 1 7 5 4 10 10 4 33 Merge Sort: Recursive Sorting 1 2 3 4 5 6 7 8 9 10MergeSort 𝐴, 1,10 2 3 6 8 9 2 6 9 6 9 9 6 2 3 8 8 3 1 4 5 7 10 1 5 7 1 7 1 7 5 4 10 10 4 Merge Merge Merge Merge Merge Merge Merge MergeMerge 34 Merge Sort: Running-time Analysis MergeSort(𝐴, 𝑝, 𝑟): 𝑇 𝑛 If 𝑝 < 𝑟 𝑞 = (𝑝 + 𝑟)/2 MergeSort 𝐴, 𝑝, 𝑞 MergeSort 𝐴, 𝑞 + 1, 𝑟 Merge 𝐴, 𝑝, 𝑟 𝑇 𝑛 = ቊΘ 1 if 𝑛 = 1 2𝑇 𝑛/2 + Θ 𝑛 if 𝑛 > 1 Θ(1) 𝑇(𝑛/2) Θ(𝑛) 𝑇(𝑛/2) Recurrence 35 Recurrence Tree 𝑇 𝑛 = ቊΘ 1 if 𝑛 = 1 2𝑇 𝑛/2 + Θ 𝑛 if 𝑛 > 1 𝑇(𝑛) 36 Recurrence Tree 𝑇 𝑛 = ቊΘ 1 if 𝑛 = 1 2𝑇 𝑛/2 + Θ 𝑛 if 𝑛 > 1 𝑛 𝑇(𝑛/2) 𝑇(𝑛/2) 37 Recurrence Tree 𝑇 𝑛 = ቊΘ 1 if 𝑛 = 1 2𝑇 𝑛/2 + Θ 𝑛 if 𝑛 > 1 𝑛 𝑛/2 𝑛/2 𝑇(𝑛/4) 𝑇(𝑛/4) 𝑇(𝑛/4) 𝑇(𝑛/4) 38 Recurrence Tree 𝑇 𝑛 = ቊΘ 1 if 𝑛 = 1 2𝑇 𝑛/2 + Θ 𝑛 if 𝑛 > 1 𝑛 𝑛/2 𝑛/2 𝑛/4 𝑛/4 𝑛/4 𝑛/4 … … … … … … … … Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) Θ(1) 𝑛 𝑛 𝑛 𝑛 … ℎ = lg 𝑛 𝑇 𝑛 = Θ 𝑛 lg 𝑛 39 Divide-and-Conquer • Merge sort is based on the divide-and-conquer design paradigm • Divide the problem into a number of subproblems • Conquer the subproblems by solving them recursively • Combine the solutions to the subproblems into a solution for the original problem • Analyzing divide-and-conquer based algorithms involves solving recurrences. 40 Insertion Sort vs. Merge Sort • Insertion sort worst-case running time = Θ(𝑛2) • Merge sort worst-case running time = Θ(𝑛 lg 𝑛) • We say merge sort is asymptotically faster than insertion sort. • In practice, merge sort beats insertion sort for values of roughly 𝑛 ≥ 30 41","libVersion":"0.2.2","langs":""}