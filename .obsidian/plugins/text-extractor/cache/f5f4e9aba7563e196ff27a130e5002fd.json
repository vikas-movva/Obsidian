{"path":".obsidian/plugins/text-extractor/cache/f5f4e9aba7563e196ff27a130e5002fd.json","text":"1 LECTURE 2: ANALYZING ALGORITHMS CP312 Algorithm Design and Analysis I Recall: The Sorting Problem • Problem: Sort a sequence of numbers in non-decreasing order • Input: A sequence of numbers 𝜋 = 𝑎1, … , 𝑎𝑛 • Output: A permutation 𝜋′ = 𝑎1 ′ , … , 𝑎𝑛 ′ of 𝜋 such that 𝑎1 ′ ≤ 𝑎2 ′ ≤ ⋯ ≤ 𝑎𝑛 ′ • An algorithm for the sorting problem is a sequence of computational steps with the above input/output specifications. • Ex: 8, 10, 1, 6, 2, 7, 3 ⇒ (1, 2,3,6,7,8,10) 2 Insertion Sort 8 10 1 6 2 7 3𝐴 3 Insertion Sort 8 10 1 6 2 7 3𝐴 4 Insertion Sort 8 1 6 2 7 3𝐴 10 5 Insertion Sort 8 1 6 2 7 3𝐴 10 8 < 10? 6 Insertion Sort 8 1 6 2 7 3𝐴 10 7 Insertion Sort 8 6 2 7 3𝐴 10 1 8 Insertion Sort 8 6 2 7 3𝐴 10 1 10 < 1? 9 Insertion Sort 8 6 2 7 3𝐴 10 1 8 < 1? 10 Insertion Sort 6 2 7 3𝐴 8 10 1 11 Insertion Sort 1 2 7 3𝐴 8 10 6 12 Insertion Sort 1 2 7 3𝐴 8 10 6 10 < 6? 13 Insertion Sort 1 2 7 3𝐴 8 10 6 8 < 6? 14 Insertion Sort 1 2 7 3𝐴 8 10 6 1 < 6? 15 Insertion Sort 1 2 7 3𝐴 8 10 6 16 Insertion Sort 1 7 3𝐴 6 8 10 2 17 Insertion Sort 1 7 3𝐴 6 8 10 2 10 < 2? 18 Insertion Sort 1 7 3𝐴 6 8 10 2 8 < 2? 19 Insertion Sort 1 7 3𝐴 6 8 10 2 6 < 2? 20 Insertion Sort 1 7 3𝐴 6 8 10 2 1 < 2? 21 Insertion Sort 1 7 3𝐴 6 8 10 2 22 Insertion Sort 1 3𝐴 2 6 8 10 7 23 Insertion Sort 1 3𝐴 2 6 8 10 7 10 < 7? 24 Insertion Sort 1 3𝐴 2 6 8 10 7 8 < 7? 25 Insertion Sort 1 3𝐴 2 6 8 10 7 6 < 7? 26 Insertion Sort 1 3𝐴 2 6 8 10 7 27 Insertion Sort 1 10𝐴 2 6 7 8 3 28 Insertion Sort 1 10𝐴 2 6 7 8 3 10 < 3? 29 Insertion Sort 1 10𝐴 2 6 7 8 3 8 < 3? 30 Insertion Sort 1 10𝐴 2 6 7 8 3 7 < 3? 31 Insertion Sort 1 10𝐴 2 6 7 8 3 6 < 3? 32 Insertion Sort 1 10𝐴 2 6 7 8 3 2 < 3? 33 Insertion Sort 1𝐴 2 106 7 8 3 34 Insertion Sort 1 8 10𝐴 2 3 6 7 35 Pseudocode Insertion_Sort(𝐴, 𝑛): 36 𝐴[1] 𝐴[2] 𝐴[𝑛]⋯ ⋯Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 37 𝐴[1] 𝐴[2] 𝐴[𝑛]⋯ ⋯Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 𝑖 = 4 1 6 8 10 2 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 Sorted 38 Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 𝑖 = 4 1 6 8 10 10 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 39 Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 6 8 10 10 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 𝑖 = 3 40 Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 6 8 8 10 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 𝑖 = 3 41 Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 6 8 8 10 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 𝑖 = 2 42 Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 6 6 8 10 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 𝑖 = 2 43 Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 6 6 8 10 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 𝑖 = 1 44 Pseudocode Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 2 6 8 10 7 3 𝑗 = 5 2 𝑡𝑒𝑚𝑝 𝑖 = 1 45 Analyzing Insertion Sort • We need to show: 1. That the algorithm is correct for ANY input. That is, it will always output a sorted array. 2. The running time of the algorithm. • This is the case for all algorithms that we will study. ◦ Except we will often put more emphasis on finding the running time 46 Analyzing Correctness • How do you prove correctness? • What were you taught to do in your Software Engineering class? ◦ Inspections ◦ Walkthroughs ◦ Testing ◦ Unit Testing ◦ Integration Testing ◦ Functional/System Testing • But testing is inconclusive and not a proof that there are no errors. 47 “Testing can only show the presence of errors, not their absence” - E. W. DijkstraAnalyzing Correctness • Definition: An algorithm is said to be correct if it completely satisfies the specification it is meant to accomplish with respect to the problem it is solving and terminates with the expected output. • We will use formal verification to prove that algorithms satisfy certain properties or invariants that ensure correctness. • Such a proof is called a Loop Invariant Proof. 48 Correctness: Loop Invariant Proof • To prove that an algorithm is correct for ANY input, we will need to show that it is correct (so far) for EVERY iteration of the loop: 1. Formulate a loop invariant that defines what correctness means 2. Initialization: Show that the loop invariant is true at the start of the first iteration 3. Maintenance: Assume loop invariant is true at the start of iteration 𝑗. Then prove it is true at the start of iteration 𝑗 + 1 4. Termination: Show that, when the loop terminates, the algorithm outputs the correct answer. 49 Analyzing Correctness Insertion_Sort(𝐴, 𝑛): for 𝑗 = 2 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 ≥ 1 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 6 8 10 2 7 3 Sorted Loop Invariant: At the start of iteration 𝑗 of the for loop, subarray 𝐴[1, … , 𝑗 − 1] is sorted. 𝑗 50 Analyzing Correctness 1 6 8 10 2 7 3 Sorted Loop Invariant: At the start of iteration 𝑗 of the for loop, subarray 𝐴[1, … , 𝑗 − 1] is sorted. 𝑗 51 • Initialization: Show that the loop invariant is true in the first iteration • Is the loop invariant true in the first iteration? • Yes. Proof: At the start of the first iteration (𝑗 = 2), the array 𝐴 1, … , 1 = 𝐴[1] is sorted (trivially) Analyzing Correctness 1 6 8 10 2 7 3 Loop Invariant: At the start of iteration 𝑗 of the for loop, subarray 𝐴[1, … , 𝑗 − 1] is sorted. 52 • Maintenance: Assume loop invariant is true at the start of iteration 𝑗. Then prove it is true at the start of iteration 𝑗 + 1 Sorted 𝑗 • Proof: Informally, if we assume that loop invariant is true at start of iteration 𝑗 then 𝐴[1, … , 𝑗 − 1] is sorted. ◦ Then, at start of iteration 𝑗 + 1 the element 𝐴[𝑗] will be inserted in the proper location within 𝐴[1, … 𝑗] by the inner while loop so 𝐴[1, … 𝑗] will also be sorted Analyzing Correctness 1 2 3 6 7 8 10 Sorted Loop Invariant: At the start of iteration 𝑗 of the for loop, subarray 𝐴[1, … , 𝑗 − 1] is sorted. 53 • Termination: Show that, when the loop terminates, the algorithm outputs the correct answer. 𝑗 • Proof: The loop terminates when 𝑗 = 𝑛 + 1. At this point, the loop invariant states that the subarray 𝐴[1, … , 𝑛 + 1 − 1] is sorted, which is the entire array – so the output is correct. Analyzing running time • The running time 𝑇 must be a function of the input; there are inputs for which the algorithm is slow and others for which the algorithm is fast. • We parametrize the running time of an algorithm with the input size. i.e., 𝑇(𝑛) where 𝑛 is the input size. 54 Types of Analyses • Worst-case: ◦ 𝑇 𝑛 = MAXIMUM running time of the algorithm on input of size 𝑛 • Average-case: ◦ 𝑇 𝑛 = EXPECTED running time of the algorithm over all inputs of size 𝑛 • Best-case: ◦ 𝑇 𝑛 = MINIMUM running time of the algorithm over input of size 𝑛 55 Types of Analyses • Worst-case: ◦ 𝑇 𝑛 = MAXIMUM running time of the algorithm on input of size 𝑛 • Average-case: ◦ 𝑇 𝑛 = EXPECTED running time of the algorithm over all inputs of size 𝑛 • Best-case: ◦ 𝑇 𝑛 = MINIMUM running time of the algorithm over input of size 𝑛 56 Worst-case running time • What is insertion’s sort worst-case running time? ◦ It depends! • Depends on: ◦ CPU clock speed ◦ Memory speed ◦ Cache size ◦ Etc. • Need a machine-independent way if measuring time! 57 Asymptotic Analysis • Main Idea: ◦ Identify the primitive operations and the data structure used ◦ Ignore machine-dependent constants and factors ◦ Examine the growth of 𝑇(𝑛) as 𝑛 → ∞ • E.g. 𝑇 𝑛 = 22𝑛2 + 41𝑛 + 12 = Θ(𝑛2) • E.g. 𝑇 𝑛 = 4𝑛2 + 3𝑛5 + 2𝑛8 = 𝜣 − Notation (informally) 1. Drop low-order terms 2. Ignore leading constants Θ(𝑛8) 58 Worst-case running time of insertion sort Insertion_Sort(𝐴, 𝑛): for 𝑗 = 1 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 > 0 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 10 8 7 6 3 2 1 1. Data structure? 2. Primitive operations? Array 59 Worst-case running time of insertion sort Insertion_Sort(𝐴, 𝑛): for 𝑗 = 1 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 > 0 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 10 8 7 6 3 2 1 1. Data structure? 2. Primitive operations? Compare, Shift, Assign Array 60 Worst-case running time of insertion sort Insertion_Sort(𝐴, 𝑛): for 𝑗 = 1 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 > 0 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 10 8 7 6 3 2 1 𝒋 #Compares #Shifts #Assign 𝑻𝒋(𝒏) 1 0 0 1 0 2 1 1 1 2+1 3 2 2 1 4+1 … … … … … n n-1 n-1 1 2(n-1)+1 𝑻 𝒏 = ෍ 𝒋 𝑻𝒋(𝒏) = ෍ 𝒋 𝟐 𝒋 − 𝟏 + 𝟏 = 𝜣(𝒏 𝟐) 61 Best-case running time of insertion sort Insertion_Sort(𝐴, 𝑛): for 𝑗 = 1 to 𝑛 𝑡𝑒𝑚𝑝 = 𝐴[𝑗] 𝑖 = 𝑗 − 1 while 𝑖 > 0 and 𝐴 𝑖 > 𝑡𝑒𝑚𝑝 𝐴 𝑖 + 1 = 𝐴[𝑖] 𝑖 = 𝑖 − 1 𝐴 𝑖 + 1 = 𝑡𝑒𝑚𝑝 1 2 3 6 7 8 10 𝒋 #Compares #Shifts #Assign 𝑻𝒋(𝒏) 1 0 0 1 0 2 1 0 1 1+1 3 1 0 1 1+1 … … … … … n 1 0 1 1+1 𝑻 𝒏 = ෍ 𝒋 𝑻𝒋(𝒏) = ෍ 𝒋 𝟐 = 𝜣(𝒏) 62 Asymptotic Analysis • What can we say about the relative performance of any two algorithms using Θ −notation? • A Θ(𝑛2) algorithm is always faster than a Θ(𝑛3) algorithm for large enough 𝒏. ◦ We say the Θ(𝑛2) algorithm is asymptotically faster than the Θ(𝑛3) one. • Though sometimes, in practice, we might favor asymptotically slower algorithms if we only care about “smaller” values of 𝑛 63 Try this example: Finding the Maximum 64 Find_Max(𝐴, 𝑛): 𝑚 = 𝐴[1] for 𝑗 = 2 to 𝑛 if 𝐴 𝑗 > 𝑚 then 𝑚 = 𝐴[𝑗] return 𝑚 • Prove correctness ◦ Define loop invariant ◦ Initialization ◦ Maintenance ◦ Termination • Find the running time Finding the Maximum: Correctness 65 • Loop invariant: At the start of iteration 𝑗, 𝑚 is the maximum of 𝐴[1, … , 𝑗 − 1] • Initialization: At start of first iteration 𝑗 = 2, it is true that 𝑚 = 𝐴[1] is clearly the maximum of subarray 𝐴 1, … , 1 = 𝐴[1] Find_Max(𝐴, 𝑛): 𝑚 = 𝐴[1] for 𝑗 = 2 to 𝑛 if 𝐴 𝑗 > 𝑚 then 𝑚 = 𝐴[𝑗] return 𝑚 Finding the Maximum: Correctness 66 Find_Max(𝐴, 𝑛): 𝑚 = 𝐴[1] for 𝑗 = 2 to 𝑛 if 𝐴 𝑗 > 𝑚 then 𝑚 = 𝐴[𝑗] return 𝑚 • Loop invariant: At the start of iteration 𝑗, 𝑚 is the maximum of 𝐴[1, … , 𝑗 − 1] • Maintenance: Assume 𝑚 is the maximum of 𝐴[1, … , 𝑗 − 1] at start of iteration 𝑗 • Then at iteration 𝑗 + 1, either 𝑚 stays the same or 𝐴[𝑗 + 1] is the new maximum. So 𝑚 now becomes the maximum of 𝐴[1, … , 𝑗] Finding the Maximum: Correctness 67 Find_Max(𝐴, 𝑛): 𝑚 = 𝐴[1] for 𝑗 = 2 to 𝑛 if 𝐴 𝑗 > 𝑚 then 𝑚 = 𝐴[𝑗] return 𝑚 • Loop invariant: At the start of iteration 𝑗, 𝑚 is the maximum of 𝐴[1, … , 𝑗 − 1] • Termination: Loop terminates when 𝑗 = 𝑛 + 1 at which point the loop invariant states that 𝑚 is the maximum of 𝐴 1, … , 𝑛 + 1 − 1 = 𝐴[1, … , 𝑛] which is indeed what is required of this algorithm","libVersion":"0.2.2","langs":""}